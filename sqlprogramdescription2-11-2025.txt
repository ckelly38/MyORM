created: 2-11-2025
modified: 2-(11, 12, 13, 14, 15, 17, 18)-2025
last updated: 2-18-2025

I WANT TO MAKE A PROGRAM AN OBJECT RELATIONSHIP MAPPER (ORM) TO DO SQL OR SQLite

THIS PROGRAM NEEDS TO BE ABLE TO HANDLE COLUMN OR TABLE CONSTRAINTS AND VALIDATIONS, INCLUDING MULTI-COLUMN CONSTRAINTS
-

ONE CAN UPDATE THE CONSTRAINT LIST FOR A CLASS AT ANY TIME, HOWEVER IF THE TABLE IS ALREADY CREATED WHAT HAPPENS?

ATTEMPT TO REEXECUTE THE CONSTRAINT CHECK AND SEE IF ALL OF THE DATA ON THE DATABASE IS VALID WITH THE NEW CONSTRAINT.
IF IT IS VALID, THE NEW CONSTRAINT CAN BE APPLIED SUCCESSFULLY.
IF NOT, FORCE BACKUP BEFORE PROCEEDING.
THE DATABASE WILL NEED TO BE DESTROYED FIRST.
THEN THE NEW CONSTRAINT CAN BE ADDED TO THE TABLE.
THEN THE DATA CAN BE RESTORED. THAT ASSUMES THAT THE DATA IS STILL VALID.


THIS PROGRAM NEEDS TO BE ABLE TO DO VALIDATIONS AND LET THE USER CREATE CUSTOM VALIDATION CODE FOR SAID COLUMNS AND CONSTRAINTS

THE DB ITSELF MUST ENFORCE SAID CONSTRAINTS:

INCLUDING DATA TYPES, AND FOREIGN OR PRIMARY KEY CONSTRAINTS...

CHECK(LENGTH(colname) < 10);

CREATE TABLE testtable (
    id INTEGER PRIMARY KEY,
    name TEXT,
    description TEXT,
    
    CHECK(LENGTH(description) >= 10));

CREATE TABLE testtable (
    id INTEGER PRIMARY KEY,
    name TEXT,
    description TEXT,
    
    CONSTRAINT CHK_Person CHECK(LENGTH(description) >= 10));

CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    
    CONSTRAINT PK_Person PRIMARY KEY (ID, LastName)
);

CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    
    CONSTRAINT PK_Person UNIQUE (ID, LastName)
);

IF THE DB NEEDS TO BE DESTROYED, BACK EVERYTHING UP FIRST
(EITHER BY CREATING AN SQL FILE THAT DUPLICATES THE OLD DATABASE, OR BY GENERATING A NEW SCRIPT THAT DOES THAT)
THIS FILE CAN THEN BE IMPORTED TO BACK UP THE DB

THE PROGRAM MUST BE ABLE TO TELL IF A CERTAIN TABLE EXISTS ON THE DATABASE
(THE PRAGMA COMMAND CAN DO THIS THERE MIGHT BE OTHERS...)

PRAGMA table_info(departments);

OR YOU CAN SELECT * FROM tablename; AND CATCH THE ERROR IF IT DOES NOT EXIST.

THE PROGRAM MUST BE ABLE TO GET EVERYTHING FROM ONE TABLE
THE PROGRAM MUST BE ABLE TO GET SOME STUFF FROM ONE TABLE
IT MUST ALSO BE ABLE TO DO THAT CONDITIONALLY:

SELECT * FROM tablename;
SELECT * FROM tablename WHERE ... AND WHERE ...;
SELECT colnamea, colnameb, ... FROM tablename;
SELECT colnamea, colnameb, ... FROM tablename WHERE ... AND WHERE ...;

SELECT DISTINCT colname FROM tablename; only selects unique data so it will give the first instance only in that case

SELECT tablename.colname FROM tablename; also works
SELECT tablenamea.colnamea, tablenameb.colnamea FROM tablenamea, tablenameb; also works

SELECT colnames, COUNT(colname) FROM tablename WHERE colname = value; returns the number of records
SELECT *, COUNT(*) FROM tablename; returns the number of records and the first one
SELECT COUNT(*) FROM tablename; returns the number of records

YOU CAN USE BETWEEN TO SAY: age BETWEEN 1 AND 3

YOU CAN USE IN AS ONE OF WHERE age IN (1, 2, 3, 12);

BEFORE ALL OF THE CONDITIONS YOU CAN GROUP THE RESULTS BY CERTAIN COLUMS

... GROUP BY (colnames)

AFTER ALL OF THE CONDITIONS YOU CAN SORT IT: ORDER BY colname ASC or DESC;

ORDER BY colnamea ASC/DESC, colnameb ASC/DESC ...

IF NOT PROVIDED, THEN ASCENDING ORDER IS USED 

AFTER ALL OF THE CONDITIONS YOU CAN LIMIT# HOW MANY RESULTS YOU WANT

YOU CAN DO LIMIT # for the number of rows you want (offset is zero).
LIMIT # OFFSET # so it starts at row number in the offset + 1 and gives you the number of rows you want
LIMIT a, b where a and b are numbers. a is the offset, and b is the number of rows you want.


THE PROGRAM MUST BE ABLE TO CREATE NEW TABLES:

CREATE TABLE table_name (id INTEGER PRIMARY KEY AUTO_INCREMENT, name TEXT, age INTEGER);
CREATE TABLE table_name (id SERIAL PRIMARY KEY, name TEXT, age INTEGER);

CREATE TABLE IF NOT EXISTS cats(id INTEGER PRIMARY KEY, name TEXT, breed TEXT, age INTEGER);
CREATE TABLE IF NOT EXISTS owners(id INTEGER PRIMARY KEY, name TEXT);

CREATE TABLE Orders (
    OrderID int NOT NULL,
    OrderNumber int NOT NULL,
    PersonID int,
    PRIMARY KEY (OrderID),
    FOREIGN KEY (PersonID) REFERENCES Persons(PersonID)
);

A FOREIGN KEY CAN HAVE MORE THAN ONE COLUM BECAUSE IT CAN REFER TO UNIQUE DATA (NOT JUST A PRIMARY KEY).
A PRIMARY KEY CAN ALSO BE COMPOSITE (COMPOSED OF MORE THAN ONE COLUMN).
HOWEVER, THIS MUST REFER TO A SPECIFIC ROW.

ForeignKey(tablename, [cola, colb]) = value
value usually just the rowid or id on the refered table, but when there are multiple columns?
does the value hold the row# which can change? OR does the value hold the value of the cols?
THE VALUE HOLDS THE VALUE OF THE COLS.
https://www.sqlite.org/foreignkeys.html

THE PROGRAM MUST BE ABLE TO ADD STUFF INTO THE DATABASE:

INSERT INTO tablename (colnamea, colnameb, ...) VALUES (values_tuple);

INSERT INTO cats (name, breed, age) VALUES ('Maru', 'scottish fold', 3), ...;
INSERT INTO cats (name, breed, age) VALUES ('Hana', 'tortoiseshell', 1);


THE PROGRAM MUST BE ABLE TO REMOVE STUFF FROM THE DATABASE (CONDITIONALLY OR NOT)
THE PROGRAM MUST BE ABLE TO REMOVE ENTIRE TABLES FROM THE DATABASE
(DELETION OF ANY KIND SHOULD TRIGGER A BACKUP BEFORE HAND)
THE USER SHOULD BE ALLOWED TO TRIGGER A BACKUP WHENEVER THE USER WANTS TO TOO.

UPDATE tablename SET colname = newvalue WHERE colname = oldvalue; sets the value for a specific column to a new value
UPDATE tablename SET colnamea = newvalue, colnameb = newvalue, ... WHERE colnamea = oldvalue; (or just use the primary key to access it).

ALTER TABLE tablename RENAME TO newtablename; renames a table
ALTER TABLE tablename RENAME COLUMN oldcolname TO newcolname; changes a column name inside of a table
ALTER TABLE tablename ADD COLUMN colname TYPE; adds a new column called colname of type TYPE to tablename
ALTER TABLE tablename DROP COLUMN colname; removes a column from a table

ALTER TABLE Persons
ADD CONSTRAINT CHK_PersonAge CHECK (Age>=18 AND City='Sandnes');

ALTER TABLE Persons
DROP CHECK CHK_PersonAge;


DELETE FROM tablename WHERE colname = value; clears the values only
DELETE FROM cats WHERE id = 3; removes the row with the unique id of 3 from the table
because id is the primary key which must be unique.

DROP TABLE tablename; deletes the table.


BACKUP DATABASE databasename
TO DISK = 'filepath'
WITH DIFFERENTIAL;


THE PROGRAM MUST BE ABLE TO RETURN JOIN COMMANDS, BUT WON'T MAKE A NEW TABLE WHEN IT DOES THIS
(THAT IS MORE FOR THE RESULTS)

https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/

INNER JOIN = JOIN
LEFT JOIN = LEFT OUTER JOIN
RIGHT JOIN = RIGHT OUTER JOIN
NATURAL JOIN
FULL JOIN

1. INNER JOIN WHICH IS SELECTED INFORMATION AND ALL COMMON INFORMATION. THINK VENN DIAGRAM THE STUFF IN THE MIDDLE SHARED BY A AND B.

SELECT s.roll_no, s.name, s.address, s.phone, s.age, sc.course_id
FROM Student s
JOIN StudentCourse sc ON s.roll_no = sc.roll_no;

SELECT table1.column1,table1.column2,table2.column1,....
FROM table1 
INNER JOIN table2
ON  table1.matching_column = table2.matching_column;

2. LEFT JOIN WHICH IS SELECTED INFORMATION AND ALL INFORMATION ON table1. THINK VENN DIAGRAM THE STUFF ON A AND COMMON STUFF.

SELECT table1.column1,table1.column2,table2.column1,....
FROM table1 
LEFT JOIN table2
ON table1.matching_column = table2.matching_column;

IF THERE IS NO MATCHING ROW ON THE RIGHT HAND SIDE, THEN IT WILL HAVE NULL ON THE RESULT.

3. RIGHT JOIN WHICH IS SELECTED INFORMATION AND ALL INFORMATION ON table2. THINK VENN DIAGRAM THE STUFF ON B AND COMMON STUFF.

SELECT table1.column1,table1.column2,table2.column1,....
FROM table1 
RIGHT JOIN table2
ON table1.matching_column = table2.matching_column;

IF THERE IS NO MATCHING ROW ON THE LEFT HAND SIDE, THEN IT WILL HAVE NULL ON THE RESULT.

4. FULL JOIN WHICH IS SELECTED INFORMATION ON BOTH TABLES A AND B, THINK OF THIS LIKE OR. A OR B. THE FULL VENN DIAGRAM IS WHAT THIS LOOKS LIKE.

THIS IS BASICALLY A LEFT JOIN AND A RIGHT JOIN IN ONE TABLE.

SELECT table1.column1,table1.column2,table2.column1,....
FROM table1 
FULL JOIN table2
ON table1.matching_column = table2.matching_column;

IF THERE IS NO MATCHING ROW ON THE LEFT HAND SIDE, THEN IT WILL HAVE NULL ON THE RESULT.
IF THERE IS NO MATCHING ROW ON THE RIGHT HAND SIDE, THEN IT WILL HAVE NULL ON THE RESULT.

5. NATURAL JOIN

CREATE INDEXES:

CREATE UNIQUE INDEX index_name
ON table_name (column1, column2, ...);

NOTE: DOES NOT HAVE TO BE UNIQUE BUT CHANGING IT WITH INDEXES AND UPDATING THE TABLES ARE SLOWER THAN WITHOUT.


SQL DATA TYPES ARE:

NULL, TEXT, INTEGER or INT OR SERIAL* (SQL ONLY), REAL (DECIMALS, DOUBLE, FLOAT, UP TO 15 DECIMAL PLACES), BLOB (BINARY DATA)
BOOLEANS are true => 1 and false => 0 and treated as INTEGERS
THERE ARE ALSO DATES.
FOR THE PRIMARY KEY AS AN INTEGER IT AUTOINCREMENTS

Primary Key: a column in a table with an identifier (ID) that uniquely identifies one specific record, or row, in a table
Foreign Key: a column in one table that refers to a primary key in another table

https://www.w3schools.com/sql/sql_datatypes.asp
https://www.w3resource.com/sqlite/sqlite-data-types.php

-----------------------------------------------------------------------------------------------------------------------

WHAT IS THE GENERAL PROCEDURE OF THE ORM?


1. STARTING AT THE BEGINNING, WE CREATE A NEW DATABASE. EITHER THAT OR WE RESYNC THE ORM WITH THE DATABASE.
(THE RESYNC PROCESS CREATES OBJECTS THAT ARE ALREADY ON THE DATABASE, SO NO NEED TO SAVE THESE).

2. THEN WE CREATE AN OBJECT THAT REPRESENTS A ROW IN THE DATABASE.

(3 AND 5 A): NOTE: THE VALIDATORS WILL RUN WHEN WE CALL THE SAVE AND UPDATE METHODS.

3B. THEN WE CALL SAVE THE DATA TO THE DATABASE.

4. THEN WE CHANGE THE VALUES ON THE OBJECT.

5B. THEN WE CALL UPDATE.

6. PERHAPS SOMEWHERE HERE THE USER DECIDES TO QUERY DIFFERENT INFORMATION ON THE DATABASE.

7. AT SOME POINT LATER ON WE DECIDE WE NO LONGER WANT THE OBJECT ON THE DATABASE.

(8A, 10A, 12A): NOTE: A BACKUP WILL BE TRIGGERED HERE BEFORE THE DATA IS REMOVED AS PART OF THE DELETE.

8B. THEN WE CALL DELETE. WE WILL ALSO WANT TO DELETE ALL OF THE BAD REFERENCES. THESE WILL NEED TO BE BACKED UP.

9. SOME POINT LATER ON WE DECIDE THAT WE DO NOT WANT THE ENTIRE TABLE ON THE DATABASE.

10B. THEN WE CALL REMOVE TABLE.

WE MAY CALL BACKUP HERE NOW.

NOTE: WE MAY JUST IGNORE THE BACKUP BUT ON THE FIRST DELETE CALL IF WE ARE GOING TO REMOVE THE ENTIRE TABLE...

11. I GUESS ON A FUTURE DATE, WE MAY DECIDE THAT WE WANT TO RESTORE THE LAST BACKUP OR AN OLDER BACKUP.

THE RESTORE PROCESS MIGHT ONLY ADD THE TABLE BACK AND REPOPULATE REFERENCES.
THE RESTORE PROCESS COULD GET RID OF THE ENTIRE DATABASE AND RE-BUILD THE WHOLE THING FROM THE FILE.
PRAY THIS DOES NOT GET INTERRUPTED. ONCE RESTORED AND REBUILT, THEN THE BACKUP CAN GET REMOVED...

12B. WE MAY EVENTUALLY DECIDE THAT WE DO NOT WANT THE ENTIRE DATABASE.

THIS DELETE WILL TRIGGER A BACKUP BEFORE IT STARTS.

-----------------------------------------------------------------------------------------------------------------------

WHAT HAPPENS WHEN A NEW OBJECT IS CREATED? IE: WHAT HAPPENS WHEN init OR THE CONSTRUCTOR IS RUN?

AN OBJECT IS AN INSTANCE OF A CLASS.
A CLASS IS A TABLE ON THE DATABASE. BUT A CLASS DOES NOT HAVE TO BE AND CAN HAVE OTHER STUFF THAT IS NOT.
AN OBJECT IS A ROW ON THE TABLE IN THE DATABASE. IT MAY CONTAIN OTHER STUFF THAT IS NOT ON THE DATABASE.
AN OBJECT CAN EXIST WITHOUT BEING ON THE DATABASE.

SO THE OBJECT JUST HOLDS THE DEFAULT VALUES AND THE CONSTRUCTOR WAS CALLED.
HOWEVER, THE TABLENAME FROM THE CLASS IS PUBLIC OR PROTECTED NOT PRIVATE.

LET US SAY OUR CLASS HAS THIS DATA THAT NEEDS TO BE PUT ON THE DATABASE.

ACTIVITIES:
id | name | difficulty | (NO FOREIGN KEYS, BUT STILL NEEDS ACCESS TO THE SIGNUPS)
1 | programming | 10 | ?

WELL IN ORDER TO PUT DATA ONTO THE DATABASE, THE TABLE MUST EXIST IN THE DATABASE.
SO IF IT DOES NOT EXIST CREATE THE TABLE.

WE DO NOT ACTUALLY PUT THE DATA ONTO THE DATABASE UNTIL SAVE HAS BEEN CALLED ON THE OBJECT.

BUT THE INSERT INTO COMMAND MUST BE RUN ONLY ONCE (WHEN NEW VALUES ARE ADDED FOR THE FIRST TIME).
THE UPDATE COMMAND CAN BE RUN MANY TIMES.

I GUESS WE CALL THE METHOD SAVE AND LET IT FIGURE OUT WHAT TO CALL OR WHICH COMMAND TO USE.


ALTHOUGH WE DO NOT REALLY NEED TO HAVE AN INIT METHOD FOR THE OBJECT, WE DO STILL NEED TO CALL OUR SUPER INIT IF NECESSARY AT THIS TIME, IT WOULD BE GREAT TO DO THAT.
SO ALTHOUGH WE WANT TO MAKE A NEW TABLE HERE, WE DO NOT NEED TO THAT.
WE DO NEED TO INITIALIZE OTHER PRIVATE VARIABLES THAT THE CLASS NEEDS.
WE DO NEED TO INITIALIZE THE DATA THAT IS TO BE STORED ON THE CLASS.
BUT THAT IS IT.

-----------------------------------------------------------------------------------------------------------------------

WHAT HAPPENS WHEN AN OBJECT IS PUT ON THE DATABASE?

TO PUT IT ON THE DATABASE WE NEED TO CALL SAVE ON THE OBJECT.
THE SAVE METHOD WILL FIRST NEED TO CHECK TO SEE IF THE TABLE EXISTS ON THE DATABASE.
IF THE TABLE DOES NOT EXIST, CREATE THE TABLE (WITH THE CONSTRAINTS, ETC.). ON THE DATABASE.
NOW THAT THE TABLE EXISTS, WE NEED TO CALL THE VALIDATORS FOR THE OBJECT.
IF THE VALIDATORS PASS, THEN THEN THE OBJECT NEEDS TO BE PUT ON THE DATABASE. WE WILL SEE IF THE CONSTRAINTS PASS.
IF THE CONSTRAINTS PASS, THEN THE OBJECT IS SUCCESSFULLY ON THE DATABASE.
IF EITHER THE VALIDATORS FAIL OR THE CONSTRAINTS FAIL, THEN THROW THE ERROR.

AT SOME POINT THE INSERT INTO COMMAND WILL NEED TO BE RUN ON THE DATABASE.


WHAT HAPPENS WHEN AN OBJECT NEEDS TO BE UPDATED?

AGAIN WE ARE SAVING DATA, BUT INSTEAD OF CREATING A NEW OBJECT. IT EXISTS.
IF THE OBJECT HAS BEEN SAVED ON THE DATABASE PREVIOUSLY, THEN WE NEED TO UPDATE THE VALUES ON THE ROW ON THE DATABASE.
IF THE OBJECT HAS NEVER BEEN SAVED ON THE DATABASE, NOW WE NEED TO ADD IT ON THE DATABASE.

AT SOME POINT THE UPDATE COMMAND WILL NEED TO BE RUN ON THE DATABASE EITHER THAT OR DELETE AND SAVE.

-----------------------------------------------------------------------------------------------------------------------

WHAT HAPPENS WHEN WE NEED TO BACKUP THE DATABASE? WHAT HAPPENS WHEN WE NEED TO RESTORE THE DATABASE?

TO BACKUP THE DATABASE WE GET ALL OF THE DATA FROM ALL OF THE TABLES IF THEY EXIST AND CREATE TWO FILES.
1. AN SQL FILE WITH THE SQL COMMANDS AS THIS CAN BE USED TO BACKUP THE DATABASE AND
2. A NEW PYTHON SEED.PY BACKUP FILE TO BACKUP THE DATABASE WITH PYTHON.

THE FOLLOWING LINES OF CODE COULD COME IN HANDY.

import os;
os.remove("game.txt");
def getIntegerInput(self, msg):
        r = -1;
        while(True):
            try:
                r = int(input(msg));
                return r;
            except:
                print("Error: it must be a number!");
        return r;

def saveAndExit(self):
        with open("game.txt", "w") as mfile:
            for r in range(3):
                for c in range(3):
                    mfile.write(self.game[r][c]);
                mfile.write("\n");
            mfile.close();
        exit();

lines = [];
        try:
            with open("game.txt", "r") as mfile:
                lines = mfile.readlines();
                mfile.close();
        except:
            print("there was a problem opening or reading game.txt! Playing a new game it is!");
            return mgame;
        print(f"lines = {lines}");

NOTE: INSTEAD OF READING THE FILE, WE MAY JUST CHOOSE TO EXECUTE IT.

1. VIA IMPORT IT AND THEN CALL ITS METHODS

import file_1;
file_1.whatevermethod();

2. VIA OS SYSTEM EXECUTION FUNCTION:

import os;
os.system("python filename.py");

3. VIA exec METHOD:

with open("file_1.py") as file:
    exec(file.read());#read returns a specified number of bytes -1 for the whole file by default.

4. VIA run METHOD CREATES A NEW THREAD PROCESS TO DO IT SEPARATELY:

import subprocess;
subprocess.run(["python", "filename.py"]);

https://www.geeksforgeeks.org/run-one-python-script-from-another-in-python/

use "raise" instead of "throw" and "except" instead of "catch" for exception or error handling
the "with" keyword/operator/function will close a resource, such as a file, automatically if there is a problem.

-----------------------------------------------------------------------------------------------------------------------

WHAT HAPPENS WHEN AN OBJECT NEEDS TO BE REMOVED?

WE NEED TO REMOVE THE DATA FROM THE DATABASE. WE NEED TO GET THE OBJECT OFTEN BY ITS ID/PRIMARY_KEY AND THEN WE CAN REMOVE IT. WE WILL NEED TO RUN A COMPLETE BACKUP OF THE DATABASE BEFORE WE GET RID OF THE DATABASE. THEN RUN THE DELETE.

AT SOME POINT ONE OF THESE COMMANDS WILL NEED TO BE RUN.

DELETE FROM tablename WHERE colname = value; clears the values only
DELETE FROM cats WHERE id = 3; removes the row with the unique id of 3 from the table
because id is the primary key which must be unique.

DROP TABLE tablename; deletes the table.

????...NOT REALLY SURE WHAT TO DO HERE...????

-----------------------------------------------------------------------------------------------------------------------

WHAT HAPPENS WHEN A TABLE NEEDS TO BE REMOVED?

WE WILL NEED TO RUN A COMPLETE BACKUP OF THE DATABASE BEFORE WE GET RID OF THE DATABASE. THEN RUN THE DELETE.

AT SOME POINT ONE OF THESE COMMANDS WILL NEED TO BE RUN.

DELETE FROM tablename WHERE colname = value; clears the values only
DELETE FROM cats WHERE id = 3; removes the row with the unique id of 3 from the table
because id is the primary key which must be unique.

DROP TABLE tablename; deletes the table.

????...NOT REALLY SURE WHAT TO DO HERE...????

-----------------------------------------------------------------------------------------------------------------------

WHAT HAPPENS WHEN THE DATA INSIDE OF AN OBJECT NEEDS TO BE PRINTED OUT? WHAT HAPPENS WHEN WE NEED TO SEE THE DATA INSIDE OF THE OBJECTS? WHAT IF THE TABLES CONTAIN FOREIGN KEYS? WHERE DOES THE SERIALIZATION STOP?

WE ALWAYS SERIALIZE ALL OF THE SAFE VALUES. IE IF IT IS NOT ON A FOERIGN KEY ON A DIFFERENT COLUMN DO NOT INCLUDE IT.
WHAT IF THE DATA IS SENSITIVE LIKE A PASSWORD? ALLOW EACH INDIVIDUAL CLASS TO OVERRIDE THE TO_DICT OR TO STRING METHOD OTHERWISE THE DEFAULT WILL BE USED. OR USE SOME SORT OF RULE ENFORCER. BUT WE NEED TO PREVENT CIRCULAR REFERENCE WHICH CAN OCCUR ESPECIALLY WITH TRANSITION TABLES...

NO COMMANDS WILL NEED TO HAPPEN ON THE DATABASE HERE.

EXAMPLE CLASSES FROM SQLALCHEMY TO ILLUSTRATE THE EXAMPLE:

class Activity(db.Model, SerializerMixin):
    __tablename__ = 'activities'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String)
    difficulty = db.Column(db.Integer)

    # Add relationship
    signups = db.relationship("Signup", back_populates="activity", cascade="all, delete-orphan");


class Camper(db.Model, SerializerMixin):
    __tablename__ = 'campers'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)
    age = db.Column(db.Integer)

    # Add relationship
    signups = db.relationship("Signup", back_populates="camper", cascade="all, delete-orphan");


class Signup(db.Model, SerializerMixin):
    __tablename__ = 'signups'

    id = db.Column(db.Integer, primary_key=True)
    time = db.Column(db.Integer)

    # Add relationships
    camper_id = db.Column(db.Integer, db.ForeignKey("campers.id"));
    activity_id = db.Column(db.Integer, db.ForeignKey("activities.id"));
    
    camper = db.relationship("Camper", back_populates="signups");
    activity = db.relationship("Activity", back_populates="signups");


IN THE ABOVE EXAMPLE EVERYTHING OTHER THAN ANYTHING WITH RELATIONSHIP FUNCTION CALL IS SAFE TO SERIALIZE.
SERIALIZING SOME STUFF LIKE PASSWORDS MIGHT POSE A SECURITY ISSUE.

THE ISSUE IS WHEN WE GO TO POPULATE THE DATA WHERE THE RELATIONSHIP FUNCTION WAS CALLED.

SINCE WE MAY WANT TO SERIALIZE THIS DATA TOO, WHAT DO WE KEEP? WHAT DO WE NOT KEEP?


EXAMPLE WITH DATA REGARDLESS OF HOW THE CODE IS WRITTEN:

ACTIVITIES:
id | name | difficulty | (NO FOREIGN KEYS, BUT STILL NEEDS ACCESS TO THE SIGNUPS)
1 | programming | 10 | ?
2 | other | 1 | ?
BUT ANYTHING THAT REFERS TO THIS TABLE IS A NO-NO.

CAMPERS:
id | name | age | (NO FOREIGN KEYS, BUT STILL NEEDS ACCESS TO SIGNUPS)
1 | me | 27 | ?
2 | sean | 26 | ?
3 | brinley | 22 | ?
BUT ANYTHING THAT REFERS TO THIS TABLE IS A NO-NO.

SIGNUPS:
id | time | camper_id (fk) | activity_id (fk)
1 | 800 | 1 | 1 | the camper | the activity | BUT NO SIGNUPS
1 | 800 | 2 | 1 | the camper | the activity | BUT NO SIGNUPS
2 | 900 | 3 | 2 | the camper | the activity | BUT NO SIGNUPS
BUT ANYTHING THAT REFERS TO THIS TABLE IS A NO-NO.



THE POPULATES METHOD WILL NEED TO WORK IN THE SAME WAY.

THE SERIALIZER WILL NEED TO HAVE A CLASS LIST EXCLUSION PARAMETER.
IT WILL ALSO NEED THE CALLING OBJECT (PROBABLY THE THIS).

WHEN WE CALL OUR SERIALIZE METHOD... WE NEED TO KNOW THE CALLING CLASS.
THE CALLING CLASS WILL BE FIRST ON THE EXCLUSION LIST.

LET US SAY WE WANT TO SERIALIZE SIGNUPS:

SERIALIZE([SIGNUPS]):
gets all of the data on the serialize class or table objects that is completely safe
then it attempts to serialize the camper object: camper.SERIALIZE([SIGNUPS, CAMPERS]);
camper.SERIALIZE([SIGNUPS, CAMPERS]):
gets all safe data of course then
it attempts to get all of the SINGUPS, but is stopped. SO IT RETURNS.
then we go back to SERIALIZE([SIGNUPS]), but not done with non-safe data so need to take our return value and add it.
then we do: activity.SERIALIZE([SIGNUPS, ACTIVITIES]);
activity.SERIALIZE([SIGNUPS, ACTIVITIES]):
gets all safe data of course then
it attempts to get all of the SINGUPS, but is stopped. SO IT RETURNS.
then we go back to SERIALIZE([SIGNUPS]), now done with non-safe data so we take our return value add it, THEN RETURN.

THIS MAY ALSO HELP:

dir() returns a list of strings of the attributes.
dir(object) returns a list of strings of the attributes of the object.
getattr(object, name) returns the values of said attributes of the object.

#WILL GIVE ACCESS TO THE VALUES OF SAID ATTRIBUTES.
for attrstr in dir(object):
    print(getattr(object, attrstr));

-----------------------------------------------------------------------------------------------------------------------

WHAT HAPPENS ON BOOT UP OF THE ORM WHEN THE DATABASE ALREADY EXISTS?

WE NEED TO SYNC THE ORM WITH THE DATABASE FIRST. IE CREATE ALL OF THE OBJECTS TO CORRESPOND WITH THE DATABASE. BUT ONLY CREATE IT ON THE ORM SIDE, AND DO NOT SAVE TO THE DATABASE AS THEY ALREADY EXIST ON IT.

WE WILL NEED TO GET OR SELECT THE DATA FROM THE DATABASE FOR EACH TABLE ON THE DATABASE.

-----------------------------------------------------------------------------------------------------------------------

HOW DO WE KNOW WHAT TABLES ARE ON THE DATABASE?

IF THE DATABASE EXISTS, THEN ALL OF THE CLASS NAMES (MORE OR LESS) WILL REPRESENT TABLES ON THE DATABASE.

THE ORM WILL NEED TO KNOW WHICH TYPE OF CLASSES ARE OUT THERE.

WE CAN ALSO DO IF TABLE NAME EXISTS VIA TRIAL AND ERROR FOR ALL OF THE TABLE NAMES FROM THE CLASSES.

I THINK THIS IS THE BEST WAY GIVEN VARIABLE WAYS GIVEN THE SCHEMA.

I GUESS WE CAN ALSO LOOK AT THE LAST BACKUP FILE OR SCRIPT TO SEE WHAT TABLES IT CREATED.


WHAT IF WE HAVE A CLASS THAT WE DO NOT WANT BACK ON THE DATABASE BUT WANT TO KEEP THE CLASS FILE THERE?


IF THE DATABASE EXISTS, WE ASSUME THAT WE HAVE CREATED ALL OF THE TABLES THAT WE WANT.
IF THE DATABASE DOES NOT EXIST, THEN WE NEED TO CREATE NEW OBJECTS AND CALL SAVE ON THEM, ETC.
OR WE RUN THE BACK UP DATABASE OR BACK UP FILE TO RECREATE EVERYTHING.

IF THE TABLE IS NOT ON THE DATABASE, BUT WE WANT THE CLASS THERE, WE JUST KEEP IT AS IS AND HOPE THE BACKUP REFLECTS THIS.

-----------------------------------------------------------------------------------------------------------------------

WHEN WRITING A VALIDATION METHOD, WHAT WILL THE CALL AND CODE LOOK LIKE?
DO WE HAVE ONE MULTI-COLUMN VALIDATOR OR MULTIPLE? WE WILL HAVE AT LEAST ONE.
WHAT DO WE PASS INTO SAID MULTI-COLUMN VALIDATOR(S)?
HOW DOES THE ORM KNOW WHICH METHODS IN THE CLASSES ARE USED FOR VALIDATION?
HOW DOES THE ORM KNOW WHICH COLUMNS HAVE MULTI-COLUMN CUSTOM VALIDATION METHODS AND WHAT TO PASS INTO THOSE METHODS?

FOR ALL VALIDATORS WE NEED TO KNOW THE NEW VALUES, PROBABLY THE OBJECTS CURRENT VALUES OR OLD VALUES, AND WHAT COLUM OR COLUMS THE SAID VALIDATOR IS VALIDATING. THE NEW VALUES CAN BE AN ARRAY. THE CURRENT COLUMNS FOR SAID VALUES CAN BE AN ARRAY. IE: SOMETHING TO ESTABLISH WHAT NEW VALUE IS FOR WHAT COLUMN.

SUPPOSE A DATABASE IS SUFFICIENTLY LARGE SAY 100 COLUMNS, IS ALLOWING ONLY ONE MULTI-COLUMN VALIDATOR A GOOD IDEA?
WOULD IT BE BETTER TO HAVE MULTIPLE? SURE IN THAT CASE IT MIGHT BE BETTER TO HAVE MULTIPLE.

SO WE WILL ALLOW MULTIPLE MULTI-COLUMN VALIDATORS.

WHAT ABOUT REGISTRATION FOR SAID VALIDATORS?

SINGLE COLUMN VALIDATORS, CAN BE REGISTERED ON THE COLUMN THAT THEY ARE VALIDATING.
BUT NOT MULTI-COLUMN VALIDATORS. SINCE THEY SPAN MULTIPLE COLUMNS.

THE ORM CLASS NEEDS TO HAVE A METHOD TO KNOW WHAT COLUMNS AND WHAT METHOD NAMES ARE NEEDED FOR EACH VALIDATOR.
THE KEY LIST OR LIST OF COLUMNS IS ALWAYS THE FIRST PARAMETER.
THE NEW VALUES LIST IS ALWAYS THE SECOND PARAMETER.
IF THERE IS ONLY KEY, THEN IT IS A SINGLE COLUMN VALIDATOR, IN THIS CASE THE PARAMETERS WILL NOT BE ARRAYS.

REGISTRATION WILL BE SIMPLE LIKE: MAYBE super. ? OR JUST this.addValidator(classname, methodname, cols);
OR MAYBE A SPECIFIC CLASS METHOD NEEDED TO BE DEVOTED TO IT INSIDE OF EACH CLASS.

WHEN THE VALIDATORS NEED TO BE RUN FOR A CERTAIN CLASS:
THE BASE TAKES THE LIST OF VALIDATORS, THEN FINDS THOSE WHERE THE CLASS NAME MATCHES, EXECUTES THOSE WITH SINGLE COLUMNS FIRST. IF THE SINGLE COLUMNS ALL RETURN TRUE IT THEN CALLS THE MULTI-COLUMNS VALIDATORS.

THE ORM WOULD IDEALLY NEED TO KNOW WHAT FUNCTIONS TO CALL AS VALIDATORS, AND WHAT PARAMETERS EACH VALIDATOR TAKES.

GENERALLY THE PARAMETERS ARE A KEY AND VALUE FOR SINGLE COLUMN VALIDATORS.
THE KEY BEING THE COLUMN NAME. THE VALUE BEING THE NEW VALUE.

BUT FOR MULTI-COLUMN VALIDATORS, EACH VALIDATOR HAS ITS OWN SET OF COLUMNS (ARRAY OF KEYS) THAT IT VALIDATES,
AND THE NEW VALUES. IN THAT ORDER.

WHICH RUNS FIRST SINGLE OR MULTI-COLUMN VALIDATORS?

SINGLE COLUMN VALIDATORS WILL RUN BEFORE THE MULTI-COLUMN ONES.
BECAUSE IF THE SINGLE COLUMN VALIDATORS CATCH A PROBLEM, THERE IS NO POINT IN HAVING THE MULTI-S RUN WITH BAD DATA.

WHAT ABOUT THE RETURN VALUE FOR VALIDATORS?
SOME SAY THE VALIDATORS SHOULD RETURN THE NEW VALUE IF VALID AND THROW AN ERROR OTHERWISE.
I THINK THE VALIDATORS SHOULD RETURN TRUE IF VALID, AND FALSE OTHERWISE, BUT LET THE ORM MAIN VALIDATOR METHOD THROW THE ERROR ON FALSE VALUE OR THE VALIDATORS COULD THROW AN ERROR. LEAVE IT UP TO THEM.

I WILL DO THE RETURN TRUE, THAT WAY THE RETURN VALUE WILL NOT CONFUSE OTHER DEVELOPERS. THE RETURN TYPE CAN BE CHECKED.
WHICH WILL CATCH A LOT MORE PROBLEMS BEFORE THEY START AS A RESULT.

#example python function not necessarily an example of a validator, but this will give you some idea.
def funcname(parama, paramb, ...):
    #code here...
    raise Error("key name was not valid");#some error if data was not valid
    return true;#on success is valid

?.addValidator(classname, methodname, [cols]);

-----------------------------------------------------------------------------------------------------------------------
